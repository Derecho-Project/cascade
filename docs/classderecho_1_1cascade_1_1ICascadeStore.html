<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cascade: derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cascade
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacederecho.html">derecho</a></li><li class="navelem"><b>cascade</b></li><li class="navelem"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">ICascadeStore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classderecho_1_1cascade_1_1ICascadeStore-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cascade__interface_8hpp_source.html">cascade_interface.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classderecho_1_1cascade_1_1ICascadeStore.png" usemap="#derecho::cascade::ICascadeStore_3C_20KT_2C_20VT_2C_20IK_2C_20IV_20_3E_map" alt=""/>
  <map id="derecho::cascade::ICascadeStore_3C_20KT_2C_20VT_2C_20IK_2C_20IV_20_3E_map" name="derecho::cascade::ICascadeStore_3C_20KT_2C_20VT_2C_20IK_2C_20IV_20_3E_map">
<area href="classderecho_1_1cascade_1_1PersistentCascadeStore.html" alt="derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;" shape="rect" coords="0,56,383,80"/>
<area href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html" alt="derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;" shape="rect" coords="393,56,776,80"/>
<area href="classderecho_1_1cascade_1_1VolatileCascadeStore.html" alt="derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;" shape="rect" coords="786,56,1169,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6428c0434bab06460d8e97ed791d464c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a6428c0434bab06460d8e97ed791d464c">KeyType</a> = KT</td></tr>
<tr class="separator:a6428c0434bab06460d8e97ed791d464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473e9266601f7dc285e5a4ccbe1c8847"><td class="memItemLeft" align="right" valign="top"><a id="a473e9266601f7dc285e5a4ccbe1c8847" name="a473e9266601f7dc285e5a4ccbe1c8847"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ObjectType</b> = VT</td></tr>
<tr class="separator:a473e9266601f7dc285e5a4ccbe1c8847"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad8d9cea806a0d5504c4292ff926524a8"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ad8d9cea806a0d5504c4292ff926524a8">put</a> (const VT &amp;value) const =0</td></tr>
<tr class="separator:ad8d9cea806a0d5504c4292ff926524a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1bfd036c1b894735454a93d47ab99f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a5a1bfd036c1b894735454a93d47ab99f">put_and_forget</a> (const VT &amp;value) const =0</td></tr>
<tr class="separator:a5a1bfd036c1b894735454a93d47ab99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3d28597302ecd4ff6a4802b4cd9c76"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a6e3d28597302ecd4ff6a4802b4cd9c76">remove</a> (const KT &amp;key) const =0</td></tr>
<tr class="separator:a6e3d28597302ecd4ff6a4802b4cd9c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab206e152e112dc4e70335cf187a6f6c8"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ab206e152e112dc4e70335cf187a6f6c8">get</a> (const KT &amp;key, const persistent::version_t &amp;ver, const bool stable, bool exact=false) const =0</td></tr>
<tr class="separator:ab206e152e112dc4e70335cf187a6f6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0937a9c38f284e153682e7d901bd207"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ad0937a9c38f284e153682e7d901bd207">multi_get</a> (const KT &amp;key) const =0</td></tr>
<tr class="separator:ad0937a9c38f284e153682e7d901bd207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00d8e5a050c135840c650e6febb90bd"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ae00d8e5a050c135840c650e6febb90bd">get_by_time</a> (const KT &amp;key, const uint64_t &amp;ts_us, const bool stable) const =0</td></tr>
<tr class="separator:ae00d8e5a050c135840c650e6febb90bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280b62d6b26f9d67ce3ae20445fc8eef"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a280b62d6b26f9d67ce3ae20445fc8eef">multi_list_keys</a> (const std::string &amp;prefix) const =0</td></tr>
<tr class="separator:a280b62d6b26f9d67ce3ae20445fc8eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec585c277acb394274f6c9c2418b0cb0"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#aec585c277acb394274f6c9c2418b0cb0">list_keys</a> (const std::string &amp;prefix, const persistent::version_t &amp;ver, const bool stable) const =0</td></tr>
<tr class="separator:aec585c277acb394274f6c9c2418b0cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cc89f310eb571959558c43c1eca58c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a53cc89f310eb571959558c43c1eca58c">list_keys_by_time</a> (const std::string &amp;prefix, const uint64_t &amp;ts_us, const bool stable) const =0</td></tr>
<tr class="separator:a53cc89f310eb571959558c43c1eca58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fa85280682c2462ef8f5081f0c720e"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ac1fa85280682c2462ef8f5081f0c720e">multi_get_size</a> (const KT &amp;key) const =0</td></tr>
<tr class="separator:ac1fa85280682c2462ef8f5081f0c720e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8fae9b27a5d256a2127a2a910df313"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a6a8fae9b27a5d256a2127a2a910df313">get_size</a> (const KT &amp;key, const persistent::version_t &amp;ver, const bool stable, const bool exact=false) const =0</td></tr>
<tr class="separator:a6a8fae9b27a5d256a2127a2a910df313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbad3c2e507c06605c34ffee82f11d74"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#adbad3c2e507c06605c34ffee82f11d74">get_size_by_time</a> (const KT &amp;key, const uint64_t &amp;ts_us, const bool stable) const =0</td></tr>
<tr class="separator:adbad3c2e507c06605c34ffee82f11d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ee4a1e22a3d464bf8754d205e28f74"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ad7ee4a1e22a3d464bf8754d205e28f74">trigger_put</a> (const VT &amp;value) const =0</td></tr>
<tr class="separator:ad7ee4a1e22a3d464bf8754d205e28f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad338f1be356f997d4a060fe424c17b1b"><td class="memItemLeft" align="right" valign="top"><a id="ad338f1be356f997d4a060fe424c17b1b" name="ad338f1be356f997d4a060fe424c17b1b"></a>
KT *&#160;</td><td class="memItemRight" valign="bottom"><b>InvKeyPtr</b> = IK</td></tr>
<tr class="separator:ad338f1be356f997d4a060fe424c17b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429df0ec2d3a37b85b5a7b41246ef059"><td class="memItemLeft" align="right" valign="top"><a id="a429df0ec2d3a37b85b5a7b41246ef059" name="a429df0ec2d3a37b85b5a7b41246ef059"></a>
VT *&#160;</td><td class="memItemRight" valign="bottom"><b>InvValPtr</b> = IV</td></tr>
<tr class="separator:a429df0ec2d3a37b85b5a7b41246ef059"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a34944f755a133f75b84940daa86f3d03"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a34944f755a133f75b84940daa86f3d03">ordered_put</a> (const VT &amp;value)=0</td></tr>
<tr class="separator:a34944f755a133f75b84940daa86f3d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedde0d0a4bacb76de3fb8fec60ca38cf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#aedde0d0a4bacb76de3fb8fec60ca38cf">ordered_put_and_forget</a> (const VT &amp;value)=0</td></tr>
<tr class="separator:aedde0d0a4bacb76de3fb8fec60ca38cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7987a7cc2d4c100dabf8ca59c37762c2"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a7987a7cc2d4c100dabf8ca59c37762c2">ordered_remove</a> (const KT &amp;key)=0</td></tr>
<tr class="separator:a7987a7cc2d4c100dabf8ca59c37762c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ecb2d75fc82bee8b8cbc3880fd4b9c"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a13ecb2d75fc82bee8b8cbc3880fd4b9c">ordered_get</a> (const KT &amp;key)=0</td></tr>
<tr class="separator:a13ecb2d75fc82bee8b8cbc3880fd4b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1205f0392dc30dc5bd69b636a38494b2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a1205f0392dc30dc5bd69b636a38494b2">ordered_list_keys</a> (const std::string &amp;prefix)=0</td></tr>
<tr class="separator:a1205f0392dc30dc5bd69b636a38494b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43eecaf78e47646c5999896dec974978"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a43eecaf78e47646c5999896dec974978">ordered_get_size</a> (const KT &amp;key)=0</td></tr>
<tr class="separator:a43eecaf78e47646c5999896dec974978"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename KT, typename VT, KT * IK, VT * IV&gt;<br />
class derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</div><p>The cascade store interface. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KT</td><td>The type of the key </td></tr>
    <tr><td class="paramname">VT</td><td>The type of the value must<ul>
<li>includes a public and mutable field 'ver' of type std::tuple&lt;version_t,uint64_t&gt; for its version and timestamp.</li>
<li>includes a public field 'key' of type KT for the key</li>
<li>TODO: enforce this with 'concepts' in C++ 20? </li>
</ul>
</td></tr>
    <tr><td class="paramname">IK</td><td>A pointer to an invalid key (generally a static member of class KT) </td></tr>
    <tr><td class="paramname">IV</td><td>A pointer to an invalid value (generally a static member of class VT) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6428c0434bab06460d8e97ed791d464c" name="a6428c0434bab06460d8e97ed791d464c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6428c0434bab06460d8e97ed791d464c">&#9670;&#160;</a></span>KeyType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::KeyType =  KT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Types </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab206e152e112dc4e70335cf187a6f6c8" name="ab206e152e112dc4e70335cf187a6f6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab206e152e112dc4e70335cf187a6f6c8">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const VT <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const persistent::version_t &amp;&#160;</td>
          <td class="paramname"><em>ver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get(const KT&amp;,const persistent::version_t&amp;)</p>
<p>Get a value by key and version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">ver</td><td>Version: if version == CURRENT_VERSION, get the latest value. </td></tr>
    <tr><td class="paramname">stable</td><td>if stable == false, we only return the data reflecting the latest locally delivered atomic broadcast. Otherwise, stable data will be returned, meaning that the persisted states returned is safe: they will survive after whole system recovery. </td></tr>
    <tr><td class="paramname">exact</td><td>The exact match flag: this function try to return the value of that key at the 'ver'. If such a value does not exists and exact is true, it will throw an exception. If such a value does not exists and exact is false, it will return the latest state of the value for 'key' before 'ver'. The former case is very efficient but the latter one is not because of reconstructing the state. Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ver' from the beginning of the log entry if 'ver' != CURRENT_VERSION, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error,if</td><td>requested value is not found. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a856ca694d30d0d9c45b19ee4d977011a">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a45f1eae1a26b7b33bf523be2eb0a390f">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a2360f52cf6dc9383147330635def128a">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="ae00d8e5a050c135840c650e6febb90bd" name="ae00d8e5a050c135840c650e6febb90bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00d8e5a050c135840c650e6febb90bd">&#9670;&#160;</a></span>get_by_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const VT <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::get_by_time </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>ts_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get_by_time(const KT&amp;, const uint64_t&amp; ts_us)</p>
<p>Get a value by key and timestamp.</p>
<p>Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ts_us' from the beginning of the log entry, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">ts_us</td><td>- timestamp in microsecond </td></tr>
    <tr><td class="paramname">stable</td><td>if stable == false, we only return the data reflecting the latest locally delivered atomic broadcast. Otherwise, stable data will be returned, meaning that the persisted states returned is safe: they will survive after whole system recovery.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a57daaad1d95597fd0a4331622d52f7d7">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a06417191b695f3499589c2d74d3a7331">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a07417101092307525ed1e9bb1ee42274">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a6a8fae9b27a5d256a2127a2a910df313" name="a6a8fae9b27a5d256a2127a2a910df313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8fae9b27a5d256a2127a2a910df313">&#9670;&#160;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::get_size </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const persistent::version_t &amp;&#160;</td>
          <td class="paramname"><em>ver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get_size(const KT&amp;,const persistent::version_t&amp;,bool)</p>
<p>Get size by version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key </td></tr>
    <tr><td class="paramname">ver</td><td>Version, if version == CURRENT_VERSION, get the latest value. </td></tr>
    <tr><td class="paramname">stable</td><td></td></tr>
    <tr><td class="paramname">exact</td><td>The exact match flag: this function try to return the value of that key at the 'ver'. If such a value does not exists and exact is true, it will throw an exception. If such a value does not exists and exact is false, it will return the latest state of the value for 'key' before 'ver'. The former case is very efficient but the latter one is not because of reconstructing the state. Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ver' from the beginning of the log entry if 'ver' != CURRENT_VERSION, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of serialized value. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a63b3e6c9c9deafdb01bb01b82fceba13">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a8bfdaf8a3024afacbdfca0e72c8373a3">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a59e105092c25a39a1bae3fe047705ebb">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="adbad3c2e507c06605c34ffee82f11d74" name="adbad3c2e507c06605c34ffee82f11d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbad3c2e507c06605c34ffee82f11d74">&#9670;&#160;</a></span>get_size_by_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::get_size_by_time </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>ts_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get_size_by_time(const KT&amp;,const uint64_t&amp;)</p>
<p>Get size by timestamp</p>
<p>Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ts_us' from the beginning of the log entry, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">ts_us</td><td>- timestamp in microsecond</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of serialized value. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a605fbf892ca54a93c18cc9f5c33948af">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a15a4b8f3f64b7fb05c64105f79f96966">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#aceff8cc55ba03ae1cf98c0193cbb2830">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="aec585c277acb394274f6c9c2418b0cb0" name="aec585c277acb394274f6c9c2418b0cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec585c277acb394274f6c9c2418b0cb0">&#9670;&#160;</a></span>list_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; KT &gt; <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::list_keys </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const persistent::version_t &amp;&#160;</td>
          <td class="paramname"><em>ver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>list_keys(const std::string&amp; prefix, const persistent::version_t&amp; ver, const bool stable)</p>
<p>List keys at version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Prefix, only the key matching this prefix will be returned. TODO: KT/VT provider should provide their own prefix matching implementation, Empty prefix matches all keys. </td></tr>
    <tr><td class="paramname">ver</td><td>Version, if version == CURRENT_VERSION, get the latest list of keys. Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ver' from the beginning of the log entry if 'ver' != CURRENT_VERSION, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process. </td></tr>
    <tr><td class="paramname">stable</td><td>if stable == false, we only return the data reflecting the latest locally delivered atomic broadcast. Otherwise, stable data will be returned, meaning that the persisted states returned is safe: they will survive after whole system recovery.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of keys. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#ad912f1166cf8aff56d20c4155fdf0fb1">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#aa4888fe6311ff26376f6efb67fc9f18a">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#ad6b78fed6ac5cb74d6c3ae6d95e29b52">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a53cc89f310eb571959558c43c1eca58c" name="a53cc89f310eb571959558c43c1eca58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cc89f310eb571959558c43c1eca58c">&#9670;&#160;</a></span>list_keys_by_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; KT &gt; <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::list_keys_by_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>ts_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>list_keys_by_time(const std::string&amp;, const uint64_t&amp;, const bool)</p>
<p>List keys by timestamp</p>
<p>Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ts_us' from the beginning of the log entry, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Prefix, only the key matching this prefix will be returned. TODO: KT/VT provider should provide their own prefix matching implementation, Empty prefix matches all keys. </td></tr>
    <tr><td class="paramname">ts_us</td><td>timestamp in microsecond </td></tr>
    <tr><td class="paramname">stable</td><td>if stable == false, we only return the data reflecting the latest locally delivered atomic broadcast. Otherwise, stable data will be returned, meaning that the persisted states returned is safe: they will survive after whole system recovery.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of keys. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a2c788adceb3de43e0a1d3f17798b8f97">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a31451eda17a01f48dea8daa3a5eea29b">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#afca4fdbcc3c05eb776f8ffb3e4e15b9e">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="ad0937a9c38f284e153682e7d901bd207" name="ad0937a9c38f284e153682e7d901bd207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0937a9c38f284e153682e7d901bd207">&#9670;&#160;</a></span>multi_get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const VT <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::multi_get </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>multi_get(const KT&amp;)</p>
<p>Get a value by key. This is an ordered get that participates atomic broadcast, which reflecting the latest global atomic broadcast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a7eb0777b3baaf45632c0bd12e5593b51">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#ae9ecea6db6539d5288bfae0a4e2c18c8">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a42d0e290de192cf3e115d15217df6324">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="ac1fa85280682c2462ef8f5081f0c720e" name="ac1fa85280682c2462ef8f5081f0c720e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fa85280682c2462ef8f5081f0c720e">&#9670;&#160;</a></span>multi_get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::multi_get_size </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>multi_get_size(const KT&amp;)</p>
<p>Get size of the latest object using atomic broadcast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of serialized value. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a7cc8c9a04842dcbd45cf76ec9c75c367">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#aadda54f4ee13993d71ff6a4184c26e62">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a4ec72f50978e5d3ef8a32d355ca1573c">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a280b62d6b26f9d67ce3ae20445fc8eef" name="a280b62d6b26f9d67ce3ae20445fc8eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280b62d6b26f9d67ce3ae20445fc8eef">&#9670;&#160;</a></span>multi_list_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; KT &gt; <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::multi_list_keys </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>multi_list_keys(const std::string&amp; prefix)</p>
<p>List the most current keys by an atomic broadcast</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Prefix, only the key matching this prefix will be returned. TODO: KT/VT provider should provide their own prefix matching implementation, Empty prefix matches all keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of keys. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#adcfc3d7edd4616da83a18388b65c9a99">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a75406bb503c70111d78d39f9254518f1">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a8bd582e520c4e85e7a1998303edc44aa">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a13ecb2d75fc82bee8b8cbc3880fd4b9c" name="a13ecb2d75fc82bee8b8cbc3880fd4b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ecb2d75fc82bee8b8cbc3880fd4b9c">&#9670;&#160;</a></span>ordered_get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const VT <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::ordered_get </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_get </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#ae18159fd72af215862dc97fa88ea39c8">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a08e061def6971e170ca2aa76098477ce">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a0c5a353c96ac2c9d0d5e72c7348d6069">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a43eecaf78e47646c5999896dec974978" name="a43eecaf78e47646c5999896dec974978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43eecaf78e47646c5999896dec974978">&#9670;&#160;</a></span>ordered_get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::ordered_get_size </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_get_size </p>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a03c31c0cb222e1bf58668d234b9c7330">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a526057e17f181bad2a707f6ef70708a2">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#ade64af5128ac5c7b540ae4b82b91615f">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a1205f0392dc30dc5bd69b636a38494b2" name="a1205f0392dc30dc5bd69b636a38494b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1205f0392dc30dc5bd69b636a38494b2">&#9670;&#160;</a></span>ordered_list_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; KT &gt; <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::ordered_list_keys </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_list_keys </p><dl class="section return"><dt>Returns</dt><dd>a list of keys. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a300c6b80e665d534196ae5c0bd4b2921">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a1bcfd95c02190c959666f8015c43cecc">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a5104d3f1b5874ebc103586c40288f1dd">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a34944f755a133f75b84940daa86f3d03" name="a34944f755a133f75b84940daa86f3d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34944f755a133f75b84940daa86f3d03">&#9670;&#160;</a></span>ordered_put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual version_tuple <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::ordered_put </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_put </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple including version number (version_t) and a timestamp in microseconds. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a81040f9ad19b9e1445bf1608b36d13d4">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a2e8c7c2e8aaeedaeb1c79976e70c79f2">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a55dac606374db1381b1021aa6e4309a6">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="aedde0d0a4bacb76de3fb8fec60ca38cf" name="aedde0d0a4bacb76de3fb8fec60ca38cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedde0d0a4bacb76de3fb8fec60ca38cf">&#9670;&#160;</a></span>ordered_put_and_forget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::ordered_put_and_forget </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_put_and_forget </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a6b05a339bbbede10e50690f404941611">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a696e45be026395f7b5388727cbe67806">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#ab427db5962e06de8a8c05c264bf5988b">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a7987a7cc2d4c100dabf8ca59c37762c2" name="a7987a7cc2d4c100dabf8ca59c37762c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7987a7cc2d4c100dabf8ca59c37762c2">&#9670;&#160;</a></span>ordered_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual version_tuple <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::ordered_remove </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_remove </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple including version number (version_t) and a timestamp in microseconds. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#ad2c862708c4075db18be911c77db9653">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a5e9f79e46cb4a5610ecc972393468f38">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a0001bdd2af036611541a72773bf10944">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="ad8d9cea806a0d5504c4292ff926524a8" name="ad8d9cea806a0d5504c4292ff926524a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d9cea806a0d5504c4292ff926524a8">&#9670;&#160;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual version_tuple <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>put(const VT&amp;)</p>
<p>Put a value. VT must implement <a class="el" href="classderecho_1_1cascade_1_1ICascadeObject.html">ICascadeObject</a> interface. The key is given in value and retrieved by <a class="el" href="classderecho_1_1cascade_1_1ICascadeObject.html#a49678fda1e20dc34d5c775c309e2da11">ICascadeObject::get_key_ref()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple including version number (version_t) and a timestamp in microseconds. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a8895d4bd695c9c4cf85fa7f3f8ec07b8">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a2557c1eb3c2695bea0ff684477f4f3d2">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a385943a563412e5799871fd1e900ea48">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a5a1bfd036c1b894735454a93d47ab99f" name="a5a1bfd036c1b894735454a93d47ab99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1bfd036c1b894735454a93d47ab99f">&#9670;&#160;</a></span>put_and_forget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::put_and_forget </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>put_and_forget(const VT&amp;)</p>
<p>Put a value. VT must implement <a class="el" href="classderecho_1_1cascade_1_1ICascadeObject.html">ICascadeObject</a> interface. The key is given in value and retrieved by <a class="el" href="classderecho_1_1cascade_1_1ICascadeObject.html#a49678fda1e20dc34d5c775c309e2da11">ICascadeObject::get_key_ref()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#afbfaa024b2fad0adee4bc26ba4c41641">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#aa628268a21d7a0394f352d1964106b8d">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a82ee4a89f479654be6d6fe0ff40d792c">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a6e3d28597302ecd4ff6a4802b4cd9c76" name="a6e3d28597302ecd4ff6a4802b4cd9c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3d28597302ecd4ff6a4802b4cd9c76">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual version_tuple <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>remove(const KT&amp;)</p>
<p>Remove a value by key. The key will still be in the map with an empty value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple including version number (version_t) and a timestamp in microseconds. </dd></dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a9353829998bc87d8fc7fbf26bfa9a860">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#a8a4412d4295f430e81790c14d84dd02a">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a2118b80498d4bb34197b2df595274b15">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="ad7ee4a1e22a3d464bf8754d205e28f74" name="ad7ee4a1e22a3d464bf8754d205e28f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ee4a1e22a3d464bf8754d205e28f74">&#9670;&#160;</a></span>trigger_put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore</a>&lt; KT, VT, IK, IV &gt;::trigger_put </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>trigger_put(const VT&amp; value)</p>
<p>Put object as a trigger. This call will not cause a store but only trigger an off-critical data path computation. Please note that this call should be handled in p2p processing thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the object to trig </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#af6f0c93b13c0f8d12ea9cc903ab0d5b3">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</a>, <a class="el" href="classderecho_1_1cascade_1_1TriggerCascadeNoStore.html#aad7cc2508bbbe61aee45f93574822940">derecho::cascade::TriggerCascadeNoStore&lt; KT, VT, IK, IV &gt;</a>, and <a class="el" href="classderecho_1_1cascade_1_1VolatileCascadeStore.html#a0352e7a8a576d618da3f2710df296866">derecho::cascade::VolatileCascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cascade/<a class="el" href="cascade__interface_8hpp_source.html">cascade_interface.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
