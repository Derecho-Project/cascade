<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cascade: derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cascade
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacederecho.html">derecho</a></li><li class="navelem"><b>cascade</b></li><li class="navelem"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">PersistentCascadeStore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classderecho_1_1cascade_1_1PersistentCascadeStore-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="persistent__store_8hpp_source.html">persistent_store.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classderecho_1_1cascade_1_1PersistentCascadeStore.png" usemap="#derecho::cascade::PersistentCascadeStore_3C_20KT_2C_20VT_2C_20IK_2C_20IV_2C_20ST_20_3E_map" alt=""/>
  <map id="derecho::cascade::PersistentCascadeStore_3C_20KT_2C_20VT_2C_20IK_2C_20IV_2C_20ST_20_3E_map" name="derecho::cascade::PersistentCascadeStore_3C_20KT_2C_20VT_2C_20IK_2C_20IV_2C_20ST_20_3E_map">
<area href="classderecho_1_1cascade_1_1ICascadeStore.html" alt="derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;" shape="rect" coords="0,0,383,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2906f2e5d6a588bf9b89497b4e21be24"><td class="memItemLeft" align="right" valign="top"><a id="a2906f2e5d6a588bf9b89497b4e21be24" name="a2906f2e5d6a588bf9b89497b4e21be24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_RPC_FUNCTIONS_WITH_NOTIFICATION</b> (<a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">PersistentCascadeStore</a>, P2P_TARGETS(<a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a8895d4bd695c9c4cf85fa7f3f8ec07b8">put</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#afbfaa024b2fad0adee4bc26ba4c41641">put_and_forget</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a9353829998bc87d8fc7fbf26bfa9a860">remove</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a856ca694d30d0d9c45b19ee4d977011a">get</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a7eb0777b3baaf45632c0bd12e5593b51">multi_get</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a57daaad1d95597fd0a4331622d52f7d7">get_by_time</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#adcfc3d7edd4616da83a18388b65c9a99">multi_list_keys</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#ad912f1166cf8aff56d20c4155fdf0fb1">list_keys</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a2c788adceb3de43e0a1d3f17798b8f97">list_keys_by_time</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a7cc8c9a04842dcbd45cf76ec9c75c367">multi_get_size</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a63b3e6c9c9deafdb01bb01b82fceba13">get_size</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a605fbf892ca54a93c18cc9f5c33948af">get_size_by_time</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#af6f0c93b13c0f8d12ea9cc903ab0d5b3">trigger_put</a>), ORDERED_TARGETS(<a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a81040f9ad19b9e1445bf1608b36d13d4">ordered_put</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a6b05a339bbbede10e50690f404941611">ordered_put_and_forget</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#ad2c862708c4075db18be911c77db9653">ordered_remove</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#ae18159fd72af215862dc97fa88ea39c8">ordered_get</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a300c6b80e665d534196ae5c0bd4b2921">ordered_list_keys</a>, <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a03c31c0cb222e1bf58668d234b9c7330">ordered_get_size</a>))</td></tr>
<tr class="separator:a2906f2e5d6a588bf9b89497b4e21be24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f0c93b13c0f8d12ea9cc903ab0d5b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#af6f0c93b13c0f8d12ea9cc903ab0d5b3">trigger_put</a> (const VT &amp;value) const override</td></tr>
<tr class="separator:af6f0c93b13c0f8d12ea9cc903ab0d5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8895d4bd695c9c4cf85fa7f3f8ec07b8"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a8895d4bd695c9c4cf85fa7f3f8ec07b8">put</a> (const VT &amp;value) const override</td></tr>
<tr class="separator:a8895d4bd695c9c4cf85fa7f3f8ec07b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfaa024b2fad0adee4bc26ba4c41641"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#afbfaa024b2fad0adee4bc26ba4c41641">put_and_forget</a> (const VT &amp;value) const override</td></tr>
<tr class="separator:afbfaa024b2fad0adee4bc26ba4c41641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9353829998bc87d8fc7fbf26bfa9a860"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a9353829998bc87d8fc7fbf26bfa9a860">remove</a> (const KT &amp;key) const override</td></tr>
<tr class="separator:a9353829998bc87d8fc7fbf26bfa9a860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856ca694d30d0d9c45b19ee4d977011a"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a856ca694d30d0d9c45b19ee4d977011a">get</a> (const KT &amp;key, const persistent::version_t &amp;ver, const bool stable, bool exact=false) const override</td></tr>
<tr class="separator:a856ca694d30d0d9c45b19ee4d977011a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb0777b3baaf45632c0bd12e5593b51"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a7eb0777b3baaf45632c0bd12e5593b51">multi_get</a> (const KT &amp;key) const override</td></tr>
<tr class="separator:a7eb0777b3baaf45632c0bd12e5593b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57daaad1d95597fd0a4331622d52f7d7"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a57daaad1d95597fd0a4331622d52f7d7">get_by_time</a> (const KT &amp;key, const uint64_t &amp;ts_us, const bool stable) const override</td></tr>
<tr class="separator:a57daaad1d95597fd0a4331622d52f7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfc3d7edd4616da83a18388b65c9a99"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#adcfc3d7edd4616da83a18388b65c9a99">multi_list_keys</a> (const std::string &amp;prefix) const override</td></tr>
<tr class="separator:adcfc3d7edd4616da83a18388b65c9a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad912f1166cf8aff56d20c4155fdf0fb1"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#ad912f1166cf8aff56d20c4155fdf0fb1">list_keys</a> (const std::string &amp;prefix, const persistent::version_t &amp;ver, const bool stable) const override</td></tr>
<tr class="separator:ad912f1166cf8aff56d20c4155fdf0fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c788adceb3de43e0a1d3f17798b8f97"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a2c788adceb3de43e0a1d3f17798b8f97">list_keys_by_time</a> (const std::string &amp;prefix, const uint64_t &amp;ts_us, const bool stable) const override</td></tr>
<tr class="separator:a2c788adceb3de43e0a1d3f17798b8f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc8c9a04842dcbd45cf76ec9c75c367"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a7cc8c9a04842dcbd45cf76ec9c75c367">multi_get_size</a> (const KT &amp;key) const override</td></tr>
<tr class="separator:a7cc8c9a04842dcbd45cf76ec9c75c367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b3e6c9c9deafdb01bb01b82fceba13"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a63b3e6c9c9deafdb01bb01b82fceba13">get_size</a> (const KT &amp;key, const persistent::version_t &amp;ver, const bool stable, bool exact=false) const override</td></tr>
<tr class="separator:a63b3e6c9c9deafdb01bb01b82fceba13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605fbf892ca54a93c18cc9f5c33948af"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a605fbf892ca54a93c18cc9f5c33948af">get_size_by_time</a> (const KT &amp;key, const uint64_t &amp;ts_us, const bool stable) const override</td></tr>
<tr class="separator:a605fbf892ca54a93c18cc9f5c33948af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81040f9ad19b9e1445bf1608b36d13d4"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a81040f9ad19b9e1445bf1608b36d13d4">ordered_put</a> (const VT &amp;value) override</td></tr>
<tr class="separator:a81040f9ad19b9e1445bf1608b36d13d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b05a339bbbede10e50690f404941611"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a6b05a339bbbede10e50690f404941611">ordered_put_and_forget</a> (const VT &amp;value) override</td></tr>
<tr class="separator:a6b05a339bbbede10e50690f404941611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c862708c4075db18be911c77db9653"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#ad2c862708c4075db18be911c77db9653">ordered_remove</a> (const KT &amp;key) override</td></tr>
<tr class="separator:ad2c862708c4075db18be911c77db9653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18159fd72af215862dc97fa88ea39c8"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#ae18159fd72af215862dc97fa88ea39c8">ordered_get</a> (const KT &amp;key) override</td></tr>
<tr class="separator:ae18159fd72af215862dc97fa88ea39c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300c6b80e665d534196ae5c0bd4b2921"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a300c6b80e665d534196ae5c0bd4b2921">ordered_list_keys</a> (const std::string &amp;prefix) override</td></tr>
<tr class="separator:a300c6b80e665d534196ae5c0bd4b2921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c31c0cb222e1bf58668d234b9c7330"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html#a03c31c0cb222e1bf58668d234b9c7330">ordered_get_size</a> (const KT &amp;key) override</td></tr>
<tr class="separator:a03c31c0cb222e1bf58668d234b9c7330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada21b01e540b8de4d38df1b093cc1a5d"><td class="memItemLeft" align="right" valign="top"><a id="ada21b01e540b8de4d38df1b093cc1a5d" name="ada21b01e540b8de4d38df1b093cc1a5d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_SERIALIZE</b> (persistent_core)</td></tr>
<tr class="separator:ada21b01e540b8de4d38df1b093cc1a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5f400825f78518a7c86bc64d462a44"><td class="memItemLeft" align="right" valign="top"><a id="ade5f400825f78518a7c86bc64d462a44" name="ade5f400825f78518a7c86bc64d462a44"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_DESERIALIZE_NOALLOC</b> (<a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">PersistentCascadeStore</a>)</td></tr>
<tr class="separator:ade5f400825f78518a7c86bc64d462a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033fd176a1c8ea914e1d646814a135d6"><td class="memItemLeft" align="right" valign="top"><a id="a033fd176a1c8ea914e1d646814a135d6" name="a033fd176a1c8ea914e1d646814a135d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ensure_registered</b> (mutils::DeserializationManager &amp;)</td></tr>
<tr class="separator:a033fd176a1c8ea914e1d646814a135d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497748cb7ae037d4d0cd96e56240b073"><td class="memItemLeft" align="right" valign="top"><a id="a497748cb7ae037d4d0cd96e56240b073" name="a497748cb7ae037d4d0cd96e56240b073"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PersistentCascadeStore</b> (persistent::PersistentRegistry *pr, <a class="el" href="classderecho_1_1cascade_1_1CriticalDataPathObserver.html">CriticalDataPathObserver</a>&lt; <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">PersistentCascadeStore</a>&lt; KT, VT, IK, IV &gt; &gt; *cw=nullptr, <a class="el" href="classderecho_1_1cascade_1_1ICascadeContext.html">ICascadeContext</a> *cc=nullptr)</td></tr>
<tr class="separator:a497748cb7ae037d4d0cd96e56240b073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143f8904b52821ef619a53b35121a3c0"><td class="memItemLeft" align="right" valign="top"><a id="a143f8904b52821ef619a53b35121a3c0" name="a143f8904b52821ef619a53b35121a3c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PersistentCascadeStore</b> (persistent::Persistent&lt; <a class="el" href="classderecho_1_1cascade_1_1DeltaCascadeStoreCore.html">DeltaCascadeStoreCore</a>&lt; KT, VT, IK, IV &gt;, ST &gt; &amp;&amp;_persistent_core, <a class="el" href="classderecho_1_1cascade_1_1CriticalDataPathObserver.html">CriticalDataPathObserver</a>&lt; <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">PersistentCascadeStore</a>&lt; KT, VT, IK, IV &gt; &gt; *cw=nullptr, <a class="el" href="classderecho_1_1cascade_1_1ICascadeContext.html">ICascadeContext</a> *cc=nullptr)</td></tr>
<tr class="separator:a143f8904b52821ef619a53b35121a3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d9cea806a0d5504c4292ff926524a8"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ad8d9cea806a0d5504c4292ff926524a8">put</a> (const VT &amp;value) const =0</td></tr>
<tr class="separator:ad8d9cea806a0d5504c4292ff926524a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1bfd036c1b894735454a93d47ab99f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a5a1bfd036c1b894735454a93d47ab99f">put_and_forget</a> (const VT &amp;value) const =0</td></tr>
<tr class="separator:a5a1bfd036c1b894735454a93d47ab99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3d28597302ecd4ff6a4802b4cd9c76"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a6e3d28597302ecd4ff6a4802b4cd9c76">remove</a> (const KT &amp;key) const =0</td></tr>
<tr class="separator:a6e3d28597302ecd4ff6a4802b4cd9c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab206e152e112dc4e70335cf187a6f6c8"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ab206e152e112dc4e70335cf187a6f6c8">get</a> (const KT &amp;key, const persistent::version_t &amp;ver, const bool stable, bool exact=false) const =0</td></tr>
<tr class="separator:ab206e152e112dc4e70335cf187a6f6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0937a9c38f284e153682e7d901bd207"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ad0937a9c38f284e153682e7d901bd207">multi_get</a> (const KT &amp;key) const =0</td></tr>
<tr class="separator:ad0937a9c38f284e153682e7d901bd207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00d8e5a050c135840c650e6febb90bd"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ae00d8e5a050c135840c650e6febb90bd">get_by_time</a> (const KT &amp;key, const uint64_t &amp;ts_us, const bool stable) const =0</td></tr>
<tr class="separator:ae00d8e5a050c135840c650e6febb90bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280b62d6b26f9d67ce3ae20445fc8eef"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a280b62d6b26f9d67ce3ae20445fc8eef">multi_list_keys</a> (const std::string &amp;prefix) const =0</td></tr>
<tr class="separator:a280b62d6b26f9d67ce3ae20445fc8eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec585c277acb394274f6c9c2418b0cb0"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#aec585c277acb394274f6c9c2418b0cb0">list_keys</a> (const std::string &amp;prefix, const persistent::version_t &amp;ver, const bool stable) const =0</td></tr>
<tr class="separator:aec585c277acb394274f6c9c2418b0cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cc89f310eb571959558c43c1eca58c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a53cc89f310eb571959558c43c1eca58c">list_keys_by_time</a> (const std::string &amp;prefix, const uint64_t &amp;ts_us, const bool stable) const =0</td></tr>
<tr class="separator:a53cc89f310eb571959558c43c1eca58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fa85280682c2462ef8f5081f0c720e"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ac1fa85280682c2462ef8f5081f0c720e">multi_get_size</a> (const KT &amp;key) const =0</td></tr>
<tr class="separator:ac1fa85280682c2462ef8f5081f0c720e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8fae9b27a5d256a2127a2a910df313"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a6a8fae9b27a5d256a2127a2a910df313">get_size</a> (const KT &amp;key, const persistent::version_t &amp;ver, const bool stable, const bool exact=false) const =0</td></tr>
<tr class="separator:a6a8fae9b27a5d256a2127a2a910df313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbad3c2e507c06605c34ffee82f11d74"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#adbad3c2e507c06605c34ffee82f11d74">get_size_by_time</a> (const KT &amp;key, const uint64_t &amp;ts_us, const bool stable) const =0</td></tr>
<tr class="separator:adbad3c2e507c06605c34ffee82f11d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ee4a1e22a3d464bf8754d205e28f74"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ad7ee4a1e22a3d464bf8754d205e28f74">trigger_put</a> (const VT &amp;value) const =0</td></tr>
<tr class="separator:ad7ee4a1e22a3d464bf8754d205e28f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a23f21f078948a8cb5918419358c603d1"><td class="memItemLeft" align="right" valign="top"><a id="a23f21f078948a8cb5918419358c603d1" name="a23f21f078948a8cb5918419358c603d1"></a>
static std::unique_ptr&lt; <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">PersistentCascadeStore</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>from_bytes</b> (mutils::DeserializationManager *dsm, uint8_t const *buf)</td></tr>
<tr class="separator:a23f21f078948a8cb5918419358c603d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3523a000ee5b8257cc4504a9f986e61c"><td class="memItemLeft" align="right" valign="top"><a id="a3523a000ee5b8257cc4504a9f986e61c" name="a3523a000ee5b8257cc4504a9f986e61c"></a>
persistent::Persistent&lt; <a class="el" href="classderecho_1_1cascade_1_1DeltaCascadeStoreCore.html">DeltaCascadeStoreCore</a>&lt; KT, VT, IK, IV &gt;, ST &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>persistent_core</b></td></tr>
<tr class="separator:a3523a000ee5b8257cc4504a9f986e61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75acb508f669ee7f940dc144d597cb11"><td class="memItemLeft" align="right" valign="top"><a id="a75acb508f669ee7f940dc144d597cb11" name="a75acb508f669ee7f940dc144d597cb11"></a>
<a class="el" href="classderecho_1_1cascade_1_1CriticalDataPathObserver.html">CriticalDataPathObserver</a>&lt; <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">PersistentCascadeStore</a>&lt; KT, VT, IK, IV &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>cascade_watcher_ptr</b></td></tr>
<tr class="separator:a75acb508f669ee7f940dc144d597cb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c982c4bfb5a6f5acf042a6ba1bc6d5"><td class="memItemLeft" align="right" valign="top"><a id="a72c982c4bfb5a6f5acf042a6ba1bc6d5" name="a72c982c4bfb5a6f5acf042a6ba1bc6d5"></a>
<a class="el" href="classderecho_1_1cascade_1_1ICascadeContext.html">ICascadeContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>cascade_context_ptr</b></td></tr>
<tr class="separator:a72c982c4bfb5a6f5acf042a6ba1bc6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classderecho_1_1cascade_1_1ICascadeStore"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classderecho_1_1cascade_1_1ICascadeStore')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a></td></tr>
<tr class="memitem:ad338f1be356f997d4a060fe424c17b1b inherit pub_attribs_classderecho_1_1cascade_1_1ICascadeStore"><td class="memItemLeft" align="right" valign="top"><a id="ad338f1be356f997d4a060fe424c17b1b" name="ad338f1be356f997d4a060fe424c17b1b"></a>
KT *&#160;</td><td class="memItemRight" valign="bottom"><b>InvKeyPtr</b> = IK</td></tr>
<tr class="separator:ad338f1be356f997d4a060fe424c17b1b inherit pub_attribs_classderecho_1_1cascade_1_1ICascadeStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429df0ec2d3a37b85b5a7b41246ef059 inherit pub_attribs_classderecho_1_1cascade_1_1ICascadeStore"><td class="memItemLeft" align="right" valign="top"><a id="a429df0ec2d3a37b85b5a7b41246ef059" name="a429df0ec2d3a37b85b5a7b41246ef059"></a>
VT *&#160;</td><td class="memItemRight" valign="bottom"><b>InvValPtr</b> = IV</td></tr>
<tr class="separator:a429df0ec2d3a37b85b5a7b41246ef059 inherit pub_attribs_classderecho_1_1cascade_1_1ICascadeStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classderecho_1_1cascade_1_1ICascadeStore"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classderecho_1_1cascade_1_1ICascadeStore')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a></td></tr>
<tr class="memitem:a6428c0434bab06460d8e97ed791d464c inherit pub_types_classderecho_1_1cascade_1_1ICascadeStore"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a6428c0434bab06460d8e97ed791d464c">KeyType</a> = KT</td></tr>
<tr class="separator:a6428c0434bab06460d8e97ed791d464c inherit pub_types_classderecho_1_1cascade_1_1ICascadeStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473e9266601f7dc285e5a4ccbe1c8847 inherit pub_types_classderecho_1_1cascade_1_1ICascadeStore"><td class="memItemLeft" align="right" valign="top"><a id="a473e9266601f7dc285e5a4ccbe1c8847" name="a473e9266601f7dc285e5a4ccbe1c8847"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ObjectType</b> = VT</td></tr>
<tr class="separator:a473e9266601f7dc285e5a4ccbe1c8847 inherit pub_types_classderecho_1_1cascade_1_1ICascadeStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34944f755a133f75b84940daa86f3d03"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a34944f755a133f75b84940daa86f3d03">ordered_put</a> (const VT &amp;value)=0</td></tr>
<tr class="separator:a34944f755a133f75b84940daa86f3d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedde0d0a4bacb76de3fb8fec60ca38cf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#aedde0d0a4bacb76de3fb8fec60ca38cf">ordered_put_and_forget</a> (const VT &amp;value)=0</td></tr>
<tr class="separator:aedde0d0a4bacb76de3fb8fec60ca38cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7987a7cc2d4c100dabf8ca59c37762c2"><td class="memItemLeft" align="right" valign="top">virtual version_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a7987a7cc2d4c100dabf8ca59c37762c2">ordered_remove</a> (const KT &amp;key)=0</td></tr>
<tr class="separator:a7987a7cc2d4c100dabf8ca59c37762c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ecb2d75fc82bee8b8cbc3880fd4b9c"><td class="memItemLeft" align="right" valign="top">virtual const VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a13ecb2d75fc82bee8b8cbc3880fd4b9c">ordered_get</a> (const KT &amp;key)=0</td></tr>
<tr class="separator:a13ecb2d75fc82bee8b8cbc3880fd4b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1205f0392dc30dc5bd69b636a38494b2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; KT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a1205f0392dc30dc5bd69b636a38494b2">ordered_list_keys</a> (const std::string &amp;prefix)=0</td></tr>
<tr class="separator:a1205f0392dc30dc5bd69b636a38494b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43eecaf78e47646c5999896dec974978"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a43eecaf78e47646c5999896dec974978">ordered_get_size</a> (const KT &amp;key)=0</td></tr>
<tr class="separator:a43eecaf78e47646c5999896dec974978"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename KT, typename VT, KT * IK, VT * IV, persistent::StorageType ST = persistent::ST_FILE&gt;<br />
class derecho::cascade::PersistentCascadeStore&lt; KT, VT, IK, IV, ST &gt;</div><p>template for persistent cascade stores.</p>
<p><a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">PersistentCascadeStore</a> is full-fledged implementation with log mechansim. Data can be stored in different persistent devices including file system(persistent::ST_FILE) or SPDK(persistent::ST_SPDK). Please note that the data is cached in memory too. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a856ca694d30d0d9c45b19ee4d977011a" name="a856ca694d30d0d9c45b19ee4d977011a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856ca694d30d0d9c45b19ee4d977011a">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VT <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const persistent::version_t &amp;&#160;</td>
          <td class="paramname"><em>ver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get(const KT&amp;,const persistent::version_t&amp;)</p>
<p>Get a value by key and version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">ver</td><td>Version: if version == CURRENT_VERSION, get the latest value. </td></tr>
    <tr><td class="paramname">stable</td><td>if stable == false, we only return the data reflecting the latest locally delivered atomic broadcast. Otherwise, stable data will be returned, meaning that the persisted states returned is safe: they will survive after whole system recovery. </td></tr>
    <tr><td class="paramname">exact</td><td>The exact match flag: this function try to return the value of that key at the 'ver'. If such a value does not exists and exact is true, it will throw an exception. If such a value does not exists and exact is false, it will return the latest state of the value for 'key' before 'ver'. The former case is very efficient but the latter one is not because of reconstructing the state. Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ver' from the beginning of the log entry if 'ver' != CURRENT_VERSION, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error,if</td><td>requested value is not found. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ab206e152e112dc4e70335cf187a6f6c8">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a57daaad1d95597fd0a4331622d52f7d7" name="a57daaad1d95597fd0a4331622d52f7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57daaad1d95597fd0a4331622d52f7d7">&#9670;&#160;</a></span>get_by_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VT <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::get_by_time </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>ts_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get_by_time(const KT&amp;, const uint64_t&amp; ts_us)</p>
<p>Get a value by key and timestamp.</p>
<p>Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ts_us' from the beginning of the log entry, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">ts_us</td><td>- timestamp in microsecond </td></tr>
    <tr><td class="paramname">stable</td><td>if stable == false, we only return the data reflecting the latest locally delivered atomic broadcast. Otherwise, stable data will be returned, meaning that the persisted states returned is safe: they will survive after whole system recovery.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ae00d8e5a050c135840c650e6febb90bd">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a63b3e6c9c9deafdb01bb01b82fceba13" name="a63b3e6c9c9deafdb01bb01b82fceba13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b3e6c9c9deafdb01bb01b82fceba13">&#9670;&#160;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::get_size </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const persistent::version_t &amp;&#160;</td>
          <td class="paramname"><em>ver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get_size(const KT&amp;,const persistent::version_t&amp;,bool)</p>
<p>Get size by version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key </td></tr>
    <tr><td class="paramname">ver</td><td>Version, if version == CURRENT_VERSION, get the latest value. </td></tr>
    <tr><td class="paramname">stable</td><td></td></tr>
    <tr><td class="paramname">exact</td><td>The exact match flag: this function try to return the value of that key at the 'ver'. If such a value does not exists and exact is true, it will throw an exception. If such a value does not exists and exact is false, it will return the latest state of the value for 'key' before 'ver'. The former case is very efficient but the latter one is not because of reconstructing the state. Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ver' from the beginning of the log entry if 'ver' != CURRENT_VERSION, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of serialized value. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a6a8fae9b27a5d256a2127a2a910df313">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a605fbf892ca54a93c18cc9f5c33948af" name="a605fbf892ca54a93c18cc9f5c33948af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605fbf892ca54a93c18cc9f5c33948af">&#9670;&#160;</a></span>get_size_by_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::get_size_by_time </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>ts_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get_size_by_time(const KT&amp;,const uint64_t&amp;)</p>
<p>Get size by timestamp</p>
<p>Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ts_us' from the beginning of the log entry, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">ts_us</td><td>- timestamp in microsecond</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of serialized value. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#adbad3c2e507c06605c34ffee82f11d74">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="ad912f1166cf8aff56d20c4155fdf0fb1" name="ad912f1166cf8aff56d20c4155fdf0fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad912f1166cf8aff56d20c4155fdf0fb1">&#9670;&#160;</a></span>list_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; KT &gt; <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::list_keys </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const persistent::version_t &amp;&#160;</td>
          <td class="paramname"><em>ver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>list_keys(const std::string&amp; prefix, const persistent::version_t&amp; ver, const bool stable)</p>
<p>List keys at version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Prefix, only the key matching this prefix will be returned. TODO: KT/VT provider should provide their own prefix matching implementation, Empty prefix matches all keys. </td></tr>
    <tr><td class="paramname">ver</td><td>Version, if version == CURRENT_VERSION, get the latest list of keys. Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ver' from the beginning of the log entry if 'ver' != CURRENT_VERSION, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process. </td></tr>
    <tr><td class="paramname">stable</td><td>if stable == false, we only return the data reflecting the latest locally delivered atomic broadcast. Otherwise, stable data will be returned, meaning that the persisted states returned is safe: they will survive after whole system recovery.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of keys. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#aec585c277acb394274f6c9c2418b0cb0">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a2c788adceb3de43e0a1d3f17798b8f97" name="a2c788adceb3de43e0a1d3f17798b8f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c788adceb3de43e0a1d3f17798b8f97">&#9670;&#160;</a></span>list_keys_by_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; KT &gt; <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::list_keys_by_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>ts_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>stable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>list_keys_by_time(const std::string&amp;, const uint64_t&amp;, const bool)</p>
<p>List keys by timestamp</p>
<p>Please note that the current Persistent&lt;T&gt; in derecho will reconstruct the state at 'ts_us' from the beginning of the log entry, which is extremely inefficient. TODO: use checkpoint cache to accelerate that process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Prefix, only the key matching this prefix will be returned. TODO: KT/VT provider should provide their own prefix matching implementation, Empty prefix matches all keys. </td></tr>
    <tr><td class="paramname">ts_us</td><td>timestamp in microsecond </td></tr>
    <tr><td class="paramname">stable</td><td>if stable == false, we only return the data reflecting the latest locally delivered atomic broadcast. Otherwise, stable data will be returned, meaning that the persisted states returned is safe: they will survive after whole system recovery.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of keys. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a53cc89f310eb571959558c43c1eca58c">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a7eb0777b3baaf45632c0bd12e5593b51" name="a7eb0777b3baaf45632c0bd12e5593b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb0777b3baaf45632c0bd12e5593b51">&#9670;&#160;</a></span>multi_get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VT <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::multi_get </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>multi_get(const KT&amp;)</p>
<p>Get a value by key. This is an ordered get that participates atomic broadcast, which reflecting the latest global atomic broadcast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ad0937a9c38f284e153682e7d901bd207">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a7cc8c9a04842dcbd45cf76ec9c75c367" name="a7cc8c9a04842dcbd45cf76ec9c75c367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc8c9a04842dcbd45cf76ec9c75c367">&#9670;&#160;</a></span>multi_get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::multi_get_size </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>multi_get_size(const KT&amp;)</p>
<p>Get size of the latest object using atomic broadcast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of serialized value. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ac1fa85280682c2462ef8f5081f0c720e">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="adcfc3d7edd4616da83a18388b65c9a99" name="adcfc3d7edd4616da83a18388b65c9a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfc3d7edd4616da83a18388b65c9a99">&#9670;&#160;</a></span>multi_list_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; KT &gt; <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::multi_list_keys </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>multi_list_keys(const std::string&amp; prefix)</p>
<p>List the most current keys by an atomic broadcast</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Prefix, only the key matching this prefix will be returned. TODO: KT/VT provider should provide their own prefix matching implementation, Empty prefix matches all keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of keys. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a280b62d6b26f9d67ce3ae20445fc8eef">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="ae18159fd72af215862dc97fa88ea39c8" name="ae18159fd72af215862dc97fa88ea39c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18159fd72af215862dc97fa88ea39c8">&#9670;&#160;</a></span>ordered_get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VT <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::ordered_get </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_get </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a13ecb2d75fc82bee8b8cbc3880fd4b9c">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a03c31c0cb222e1bf58668d234b9c7330" name="a03c31c0cb222e1bf58668d234b9c7330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c31c0cb222e1bf58668d234b9c7330">&#9670;&#160;</a></span>ordered_get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::ordered_get_size </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_get_size </p>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a43eecaf78e47646c5999896dec974978">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a300c6b80e665d534196ae5c0bd4b2921" name="a300c6b80e665d534196ae5c0bd4b2921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300c6b80e665d534196ae5c0bd4b2921">&#9670;&#160;</a></span>ordered_list_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; KT &gt; <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::ordered_list_keys </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_list_keys </p><dl class="section return"><dt>Returns</dt><dd>a list of keys. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a1205f0392dc30dc5bd69b636a38494b2">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a81040f9ad19b9e1445bf1608b36d13d4" name="a81040f9ad19b9e1445bf1608b36d13d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81040f9ad19b9e1445bf1608b36d13d4">&#9670;&#160;</a></span>ordered_put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">version_tuple <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::ordered_put </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_put </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple including version number (version_t) and a timestamp in microseconds. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a34944f755a133f75b84940daa86f3d03">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a6b05a339bbbede10e50690f404941611" name="a6b05a339bbbede10e50690f404941611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b05a339bbbede10e50690f404941611">&#9670;&#160;</a></span>ordered_put_and_forget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::ordered_put_and_forget </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_put_and_forget </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#aedde0d0a4bacb76de3fb8fec60ca38cf">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="ad2c862708c4075db18be911c77db9653" name="ad2c862708c4075db18be911c77db9653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c862708c4075db18be911c77db9653">&#9670;&#160;</a></span>ordered_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">version_tuple <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::ordered_remove </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ordered_remove </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple including version number (version_t) and a timestamp in microseconds. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a7987a7cc2d4c100dabf8ca59c37762c2">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a8895d4bd695c9c4cf85fa7f3f8ec07b8" name="a8895d4bd695c9c4cf85fa7f3f8ec07b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8895d4bd695c9c4cf85fa7f3f8ec07b8">&#9670;&#160;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">version_tuple <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>put(const VT&amp;)</p>
<p>Put a value. VT must implement <a class="el" href="classderecho_1_1cascade_1_1ICascadeObject.html">ICascadeObject</a> interface. The key is given in value and retrieved by <a class="el" href="classderecho_1_1cascade_1_1ICascadeObject.html#a49678fda1e20dc34d5c775c309e2da11">ICascadeObject::get_key_ref()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple including version number (version_t) and a timestamp in microseconds. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ad8d9cea806a0d5504c4292ff926524a8">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="afbfaa024b2fad0adee4bc26ba4c41641" name="afbfaa024b2fad0adee4bc26ba4c41641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfaa024b2fad0adee4bc26ba4c41641">&#9670;&#160;</a></span>put_and_forget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::put_and_forget </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>put_and_forget(const VT&amp;)</p>
<p>Put a value. VT must implement <a class="el" href="classderecho_1_1cascade_1_1ICascadeObject.html">ICascadeObject</a> interface. The key is given in value and retrieved by <a class="el" href="classderecho_1_1cascade_1_1ICascadeObject.html#a49678fda1e20dc34d5c775c309e2da11">ICascadeObject::get_key_ref()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a5a1bfd036c1b894735454a93d47ab99f">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="a9353829998bc87d8fc7fbf26bfa9a860" name="a9353829998bc87d8fc7fbf26bfa9a860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9353829998bc87d8fc7fbf26bfa9a860">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">version_tuple <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const KT &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>remove(const KT&amp;)</p>
<p>Remove a value by key. The key will still be in the map with an empty value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple including version number (version_t) and a timestamp in microseconds. </dd></dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#a6e3d28597302ecd4ff6a4802b4cd9c76">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<a id="af6f0c93b13c0f8d12ea9cc903ab0d5b3" name="af6f0c93b13c0f8d12ea9cc903ab0d5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f0c93b13c0f8d12ea9cc903ab0d5b3">&#9670;&#160;</a></span>trigger_put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KT , typename VT , KT * IK, VT * IV, persistent::StorageType ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classderecho_1_1cascade_1_1PersistentCascadeStore.html">derecho::cascade::PersistentCascadeStore</a>&lt; KT, VT, IK, IV, ST &gt;::trigger_put </td>
          <td>(</td>
          <td class="paramtype">const VT &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>trigger_put(const VT&amp; value)</p>
<p>Put object as a trigger. This call will not cause a store but only trigger an off-critical data path computation. Please note that this call should be handled in p2p processing thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the object to trig </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classderecho_1_1cascade_1_1ICascadeStore.html#ad7ee4a1e22a3d464bf8754d205e28f74">derecho::cascade::ICascadeStore&lt; KT, VT, IK, IV &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cascade/<a class="el" href="persistent__store_8hpp_source.html">persistent_store.hpp</a></li>
<li>include/cascade/detail/<a class="el" href="persistent__store__impl_8hpp_source.html">persistent_store_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
