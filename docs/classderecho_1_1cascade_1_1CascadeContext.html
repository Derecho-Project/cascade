<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cascade: derecho::cascade::CascadeContext&lt; CascadeTypes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cascade
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacederecho.html">derecho</a></li><li class="navelem"><b>cascade</b></li><li class="navelem"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">CascadeContext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classderecho_1_1cascade_1_1CascadeContext-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">derecho::cascade::CascadeContext&lt; CascadeTypes &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for derecho::cascade::CascadeContext&lt; CascadeTypes &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classderecho_1_1cascade_1_1CascadeContext.png" usemap="#derecho::cascade::CascadeContext_3C_20CascadeTypes_20_3E_map" alt=""/>
  <map id="derecho::cascade::CascadeContext_3C_20CascadeTypes_20_3E_map" name="derecho::cascade::CascadeContext_3C_20CascadeTypes_20_3E_map">
<area href="classderecho_1_1cascade_1_1ICascadeContext.html" alt="derecho::cascade::ICascadeContext" shape="rect" coords="0,56,319,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afbed731303cb491e4d41aa6aa32c3fbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#afbed731303cb491e4d41aa6aa32c3fbc">CascadeContext</a> ()</td></tr>
<tr class="separator:afbed731303cb491e4d41aa6aa32c3fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958331e2d36df039dac7e8144c7fa24b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#a958331e2d36df039dac7e8144c7fa24b">construct</a> ()</td></tr>
<tr class="separator:a958331e2d36df039dac7e8144c7fa24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af668c0a8ee7733038f7c099a87ee0822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classderecho_1_1cascade_1_1ServiceClient.html">ServiceClient</a>&lt; CascadeTypes... &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#af668c0a8ee7733038f7c099a87ee0822">get_service_client_ref</a> () const</td></tr>
<tr class="separator:af668c0a8ee7733038f7c099a87ee0822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa42f2c91df3883f790410d35754f63"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#a8aa42f2c91df3883f790410d35754f63">register_prefixes</a> (const std::string &amp;dfg_uuid, const std::unordered_set&lt; std::string &gt; &amp;prefixes, const DataFlowGraph::VertexShardDispatcher shard_dispatcher, const DataFlowGraph::VertexHook hook, const std::string &amp;user_defined_logic_id, const std::string &amp;user_defined_logic_config, const std::shared_ptr&lt; <a class="el" href="classderecho_1_1cascade_1_1OffCriticalDataPathObserver.html">OffCriticalDataPathObserver</a> &gt; &amp;ocdpo_ptr, const std::unordered_map&lt; std::string, bool &gt; &amp;outputs)</td></tr>
<tr class="separator:a8aa42f2c91df3883f790410d35754f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05cdddcd3f3f863e1b453dedcfb82ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#ad05cdddcd3f3f863e1b453dedcfb82ff">unregister_prefixes</a> (const std::string &amp;dfg_uuid)</td></tr>
<tr class="separator:ad05cdddcd3f3f863e1b453dedcfb82ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee7c87a8fb09f5c45ac3814a793c44a"><td class="memItemLeft" align="right" valign="top">virtual match_results_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#a3ee7c87a8fb09f5c45ac3814a793c44a">get_prefix_handlers</a> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a3ee7c87a8fb09f5c45ac3814a793c44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd338ac8ab5c076f0910e172504ff15b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#acd338ac8ab5c076f0910e172504ff15b">post</a> (<a class="el" href="structderecho_1_1cascade_1_1Action.html">Action</a> &amp;&amp;action, bool is_trigger)</td></tr>
<tr class="separator:acd338ac8ab5c076f0910e172504ff15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a0e6f13134f07dc649e0cbba3dfd6c"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#a56a0e6f13134f07dc649e0cbba3dfd6c">stateless_action_queue_length_p2p</a> ()</td></tr>
<tr class="separator:a56a0e6f13134f07dc649e0cbba3dfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249617d12d3b115cd031447ea020e033"><td class="memItemLeft" align="right" valign="top"><a id="a249617d12d3b115cd031447ea020e033" name="a249617d12d3b115cd031447ea020e033"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>stateless_action_queue_length_multicast</b> ()</td></tr>
<tr class="separator:a249617d12d3b115cd031447ea020e033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe96a9acb854fc6ada1439a021724a0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#a6fe96a9acb854fc6ada1439a021724a0">~CascadeContext</a> ()</td></tr>
<tr class="separator:a6fe96a9acb854fc6ada1439a021724a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a15d5eeffbe5a0c5d8f90cd17e8735517"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classderecho_1_1cascade_1_1ResourceDescriptor.html">ResourceDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#a15d5eeffbe5a0c5d8f90cd17e8735517">resource_descriptor</a></td></tr>
<tr class="separator:a15d5eeffbe5a0c5d8f90cd17e8735517"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename... CascadeTypes&gt;<br />
class derecho::cascade::CascadeContext&lt; CascadeTypes &gt;</div><p>This file defines the API between cascade service and data path logic manager a.k.a. UDLM.</p>
<p>On cascade service initialization, it first loads all the prefixes from the data path logic. Later, upon request, corresponding handlers are loaded lazily.</p>
<p>TODO: in the future, we should provide a console to the cascade server so that a cascade administrator is able to load/unload it manually. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afbed731303cb491e4d41aa6aa32c3fbc" name="afbed731303cb491e4d41aa6aa32c3fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbed731303cb491e4d41aa6aa32c3fbc">&#9670;&#160;</a></span>CascadeContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... CascadeTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">derecho::cascade::CascadeContext</a>&lt; CascadeTypes &gt;::CascadeContext</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor </p>

</div>
</div>
<a id="a6fe96a9acb854fc6ada1439a021724a0" name="a6fe96a9acb854fc6ada1439a021724a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe96a9acb854fc6ada1439a021724a0">&#9670;&#160;</a></span>~CascadeContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... CascadeTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">derecho::cascade::CascadeContext</a>&lt; CascadeTypes &gt;::~<a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">CascadeContext</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a958331e2d36df039dac7e8144c7fa24b" name="a958331e2d36df039dac7e8144c7fa24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958331e2d36df039dac7e8144c7fa24b">&#9670;&#160;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... CascadeTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">derecho::cascade::CascadeContext</a>&lt; CascadeTypes &gt;::construct</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct the resources from <a class="el" href="namespaceDerecho.html">Derecho</a> configuration.</p>
<p>We enforce an explicit call to this initialization function to avoid heavily relying on the order of C++ global/static variables: <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">CascadeContext</a> relies on the global configuration from derecho implementation, which is generally initialized with commandline parameters in main(). If we initialize the <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">CascadeContext</a> singleton in its constructor, which happens before main(), it might miss extra configuration from commandline. Therefore, <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">CascadeContext</a> singleton needs to be initialized in main() by calling <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#a958331e2d36df039dac7e8144c7fa24b">CascadeContext::construct()</a>. Moreover, it needs the off critical data path handler from main();</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>The group handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ee7c87a8fb09f5c45ac3814a793c44a" name="a3ee7c87a8fb09f5c45ac3814a793c44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee7c87a8fb09f5c45ac3814a793c44a">&#9670;&#160;</a></span>get_prefix_handlers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... CascadeTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">match_results_t <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">derecho::cascade::CascadeContext</a>&lt; CascadeTypes &gt;::get_prefix_handlers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the prefix handlers registered for a prefix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- the prefix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unordered map of observers registered to this prefix. </dd></dl>

</div>
</div>
<a id="af668c0a8ee7733038f7c099a87ee0822" name="af668c0a8ee7733038f7c099a87ee0822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af668c0a8ee7733038f7c099a87ee0822">&#9670;&#160;</a></span>get_service_client_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... CascadeTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classderecho_1_1cascade_1_1ServiceClient.html">ServiceClient</a>&lt; CascadeTypes... &gt; &amp; <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">derecho::cascade::CascadeContext</a>&lt; CascadeTypes &gt;::get_service_client_ref</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get the reference to encapsulated service client handle. The reference is valid only after <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html#a958331e2d36df039dac7e8144c7fa24b">construct()</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to service client. </dd></dl>

</div>
</div>
<a id="acd338ac8ab5c076f0910e172504ff15b" name="acd338ac8ab5c076f0910e172504ff15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd338ac8ab5c076f0910e172504ff15b">&#9670;&#160;</a></span>post()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... CascadeTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">derecho::cascade::CascadeContext</a>&lt; CascadeTypes &gt;::post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structderecho_1_1cascade_1_1Action.html">Action</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_trigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>post an action to the Context for processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action </td></tr>
    <tr><td class="paramname">stateful</td><td>If the action is stateful|stateless|singlethreaded </td></tr>
    <tr><td class="paramname">is_trigger</td><td>True for trigger, meaning the action will be processed in the workhorses for p2p send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for a successful post, false for failure. The current only reason for failure is to post to a context already shut down. </dd></dl>

</div>
</div>
<a id="a8aa42f2c91df3883f790410d35754f63" name="a8aa42f2c91df3883f790410d35754f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa42f2c91df3883f790410d35754f63">&#9670;&#160;</a></span>register_prefixes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... CascadeTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">derecho::cascade::CascadeContext</a>&lt; CascadeTypes &gt;::register_prefixes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dfg_uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataFlowGraph::VertexShardDispatcher&#160;</td>
          <td class="paramname"><em>shard_dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataFlowGraph::VertexHook&#160;</td>
          <td class="paramname"><em>hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>user_defined_logic_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>user_defined_logic_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classderecho_1_1cascade_1_1OffCriticalDataPathObserver.html">OffCriticalDataPathObserver</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ocdpo_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::string, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md14"></a>
We give up the following on-demand loading mechanism:</h1>
<p>The prefix registry management APIs</p>
<p>We separate the prefix registration in two stages: preregistration and registration to support lazy loading of the data path logic packages. During preregistration stage, we create an entry for the corresponding prefix in the registry with an empty value. During registration stage, the prefix is filled.</p>
<p>IMPORTANT: the prefix registry management API are designed for use ONLY in the critical data path. Since the critical data path is a single thread, we don't use any lock for high performance. Please keep that in mind and don't touch the following APIs in prefix handlers where you have access to all the <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">CascadeContext</a> APIs.</p>
<ul>
<li>preregister_prefixes() allows batching preregistration of a set of prefixes, previous registered OCDPO will be overwritten by the new prefixes.</li>
<li>register_prefix() setup the OCDPO for the corresponding prefix. If the ocdpo_ptr is nullptr, the prefix is "preregister"ed.</li>
<li>unregister_prefix() deletes a corresponding prefix from registry.</li>
<li>get_prefix_handler() returns a raw pointer to the handler.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefixes</td><td>a list of vectors to pre-register. </td></tr>
    <tr><td class="paramname">prefix</td><td>a prefix to register. </td></tr>
    <tr><td class="paramname">ocdpo_ptr</td><td>the data path observer, nullptr for preregistration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>get_prefix_handler returns the <a class="el" href="classderecho_1_1cascade_1_1OffCriticalDataPathObserver.html">OffCriticalDataPathObserver</a> it holds for the corresponding prefix. If the prefix is not registered, it will return nullptr.</dd></dl>
<p>virtual void preregister_prefixes(const std::vector&lt;std::string&gt;&amp; prefixes); virtual void register_prefix(const std::string&amp; prefix, const std::shared_ptr&lt;OffCriticalDataPathObserver&gt;&amp; ocdpo_ptr = nullptr); virtual void unregister_prefix(const std::string&amp; prefix); </p>
<h1><a class="anchor" id="autotoc_md15"></a>
virtual OffCriticalDataPathObserver* get_prefix_handler(const std::string&amp; prefix);</h1>
<p>Now we agree on the new design that the prefix is assumed to be registered before the critical data path saw some data coming. Without a lock guarding prefix registry in the critical data path, it's a little bit tricky to support runtime update.</p>
<p>IMPORTANT: Successful unregistration of a prefix does not guarantee the corresponding UDL is safe to be released. Because a previous triggered off-critical data path might still working on the unregistered prefix. TODO: find a mechanism to trigger safe UDL unloading. Register a ocdpo of a given application designated by dfg uuid to a set of prefixes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfg_uuid</td><td>- the dfg uuid </td></tr>
    <tr><td class="paramname">prefixes</td><td>- the prefixes set </td></tr>
    <tr><td class="paramname">user_defined_logic_hook</td><td><ul>
<li>the hook for this ocdpo </li>
</ul>
</td></tr>
    <tr><td class="paramname">shard_dispatcher</td><td>- the shard dispatcher </td></tr>
    <tr><td class="paramname">user_defined_logic_id</td><td>- the UDL id, presumably an UUID string </td></tr>
    <tr><td class="paramname">user_defined_logic_config</td><td><ul>
<li>the UDL configuration. </li>
</ul>
</td></tr>
    <tr><td class="paramname">ocdpo_ptr</td><td>- the data path observer </td></tr>
    <tr><td class="paramname">outputs</td><td>- the outputs are a map from another prefix to put type (true for trigger put, false for put). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56a0e6f13134f07dc649e0cbba3dfd6c" name="a56a0e6f13134f07dc649e0cbba3dfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a0e6f13134f07dc649e0cbba3dfd6c">&#9670;&#160;</a></span>stateless_action_queue_length_p2p()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... CascadeTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">derecho::cascade::CascadeContext</a>&lt; CascadeTypes &gt;::stateless_action_queue_length_p2p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the stateless action queue length</p>
<dl class="section return"><dt>Returns</dt><dd>current queue_length </dd></dl>

</div>
</div>
<a id="ad05cdddcd3f3f863e1b453dedcfb82ff" name="ad05cdddcd3f3f863e1b453dedcfb82ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05cdddcd3f3f863e1b453dedcfb82ff">&#9670;&#160;</a></span>unregister_prefixes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... CascadeTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">derecho::cascade::CascadeContext</a>&lt; CascadeTypes &gt;::unregister_prefixes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dfg_uuid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unregister all prefixes of an application</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfg_uuid</td><td>- the uuid of the dfg </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a15d5eeffbe5a0c5d8f90cd17e8735517" name="a15d5eeffbe5a0c5d8f90cd17e8735517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d5eeffbe5a0c5d8f90cd17e8735517">&#9670;&#160;</a></span>resource_descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... CascadeTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classderecho_1_1cascade_1_1ResourceDescriptor.html">ResourceDescriptor</a> <a class="el" href="classderecho_1_1cascade_1_1CascadeContext.html">derecho::cascade::CascadeContext</a>&lt; CascadeTypes &gt;::resource_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resources </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cascade/<a class="el" href="service_8hpp_source.html">service.hpp</a></li>
<li>include/cascade/detail/<a class="el" href="service__impl_8hpp_source.html">service_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
