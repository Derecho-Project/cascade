<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cascade: Cascade Data Distribution Service (DDS)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cascade
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Cascade Data Distribution Service (DDS) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md31"></a>Cascade DDS is a pub/sub system implemented as a Cascade Application. It consists of three components:</p><ul>
<li>a client side library for developing DDS applications: <code>libcascade_dds.so</code>,</li>
<li>a server side UDL running in Cascade servers' address space: <code>libcascade_dds_udl.so</code>,</li>
<li>a DDS configuration file defining DDS's metadata service, data plane, and control plane, which will be discussed later: <code>dds.cfg</code>, and</li>
<li>DDS service's object pool (we plan to use 'placement group' for 'object pool' in the future) layout: <code>dfgs.json</code></li>
</ul>
<p>Use of the Cascade DDS requires some understanding of its internals, so before diving into the client API (which is quite simple), we should first talk about a few of the main concepts relevant to the Cascade DDS, and review the deployment architecture: as a developer, you'll be responsible for setting this up. With that out of the way, we'll review the client API, which is quite simple and hides most of the internals &ndash; the reason for reviewing them first is because a developer who understands how the system works will obtain better performance and be able to leverage more of the functionality of the system than one who just closes their eyes to these aspects. In the DDS, a topic maps to a key in some <em>object pool</em> in the Cascade Service (similar to a partition group in Kafka).</p>
<p>An application using the DDS is said to be a "client", or sometimes an "external client" &ndash; the distinction won't be important for this documentation, but refers to whether the client belongs to the pool of servers (the top-level Cascade group), versus just being connected to it on a datacenter or Internet link. To publish to a topic, a DDS client simply publishes a key/value pair with the key corresponding to the topic and the blob value representing the message, using an API we call "put".</p>
<p>As these messages are received, the Cascade DDS library (technically, what we refer to as a user-defined library (UDL), which is a special form of dynamically linked library loaded into the Cascade servers) will check for subscribers on the associated topic. If so, it relays the message to all the subscribers using Cascade server side notification. To subscribe to a topic, a DDS client does two things: one is to create and register a lambda function (a message handler) in a local registry maintained by the client side library, specifying the topic; the other is to publish (via put) a key/value pair that functions as a control message. The key of the control message is the topic key with a control plane suffix (defined in <code>dds.cfg</code>). On receiving a control message, the DDS UDL will pick it from the data plane and modify the subscriber's status in the server's local memory. Unsubscribing is done similarly.</p>
<p>DDS topics are stored as metadata in a separate Cascade object pool defined in <code>dds.cfg</code>. The DDS metadata is simply an object pool, which is normally configured as persistent (retained across complete shutdown/restart sequences). The keys for key-value objects in this pool will be the topic names and the values correspond to messages published to the topic. For example, a key pair "topic_a":"/dds/tiny_text" indicates that the topic "topic_a" is backed up by the object pool "/dds/tiny_text". To publish to "topic_a", the DDS client will append the topic name after the object pool to derive the key "/dds/tiny_text/topic_a" for its internal <code>put</code> operation.</p>
<p>The control plane suffix in <code>dds.cfg</code> indicates how to separate control messages from data. In the above example, let's assume the control plan suffix is '<b>control</b>', which is the default value. To subscribe to "topic_a", a DDS client will put a K/V pair to the same object pool of the data plane "/dds/tiny_text". Instead of using the data plane topic key, it append the control plan suffix to derive the key for the control plane, which is "/dds/tiny_text/topic_a/__control__". The value is a serialized request of subscribing to topic "topic_a".</p>
<p>As noted at the outset, the client library hides all of these details behind a set of <a href="include/cascade_dds/dds.hpp">clean and simple APIs</a> for application developers.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
A Step-by-step Tutorial</h2>
<p>Cascade DDS depends on Cascade and <a class="el" href="namespaceDerecho.html">Derecho</a>. Please make sure <a class="el" href="namespaceDerecho.html">Derecho</a> and Cascade are installed correctly before following this section.</p>
<p>1) Build Cascade DDS</p>
<div class="fragment"><div class="line"># mkdir build; cd build</div>
<div class="line"># cmake ..</div>
<div class="line"># make -j `nproc`</div>
</div><!-- fragment --><p> You should see the following three binaries after building it successfully</p><ul>
<li><code>libcascade_dds.so</code> the client side library,</li>
<li><code>libcascade_dds_udl.so</code> the UDL for DDS service, and</li>
<li><code>cascade_dds_client</code> a demo client showing how to use cascade dds.</li>
</ul>
<p>2) Run Test</p>
<p>In the build folder, you should see a folder called 'cfg', which contains the configuration for a local DDS service deployment, which consists only two Cascade server nodes.</p><ul>
<li><em>Start the service</em>. Start two consoles and cd to 'cfg/n0' and 'cfg/n1' respectively. From there, you can start the service by simply run <code>cascade_server</code>. Once two servers are all started, you should see a message on both console saying 'Press Enter to Shutdown.' <div class="fragment"><div class="line"># cd cfg/n0</div>
<div class="line"># cascade_server</div>
<div class="line">Press Enter to Shutdown.</div>
</div><!-- fragment --></li>
<li><em>Create the object pools for DDS metadata and data planes</em>. We need to create the object pools for DDS metadata and data planes. Those object pools are defined in <code>dds.json</code>. Start a third console and change directory to 'cfg/n2', which will be used for the external client. <div class="fragment"><div class="line"># cd cfg/n2</div>
<div class="line"># cat dds.json</div>
<div class="line">{</div>
<div class="line">    &quot;metadata_pathname&quot;: &quot;/dds/metadata&quot;,</div>
<div class="line">    &quot;data_plane_pathnames&quot;: [&quot;/dds/tiny_text&quot;,&quot;/dds/big_chunk&quot;],</div>
<div class="line">    &quot;control_plane_suffix&quot;: &quot;__control__&quot;</div>
<div class="line">}</div>
</div><!-- fragment --> Here we need to create three object pools. "/dds/metadata" is for the DDS metadata, which should be persistent. "/dds/tiny_text" is for the topics only with small messages like texts, while "/dds/big_chunk" is for the topics with big data chunks. Both the latter two object pools are volatile. <div class="fragment"><div class="line"># cascade_client create_object_pool /dds/metadata PCSS 0</div>
<div class="line">node(0) replied with version:0,ts_us:1650245329817136</div>
<div class="line">create_object_pool is done.</div>
<div class="line">-&gt; Succeeded.</div>
<div class="line"># cascade_client create_object_pool /dds/tiny_text VCSS 0</div>
<div class="line">node(0) replied with version:1,ts_us:1650245395509445</div>
<div class="line">create_object_pool is done.</div>
<div class="line">-&gt; Succeeded.</div>
<div class="line"># cascade_client create_object_pool /dds/big_chunk VCSS 0</div>
<div class="line">node(0) replied with version:2,ts_us:1650245683243300</div>
<div class="line">create_object_pool is done.</div>
<div class="line">-&gt; Succeeded.</div>
<div class="line"># cascade_client list_object_pools</div>
<div class="line">refreshed object pools:</div>
<div class="line">        /dds/tiny_text</div>
<div class="line">        /dds/metadata</div>
<div class="line">        /dds/big_chunk</div>
<div class="line">-&gt; Succeeded.</div>
</div><!-- fragment --> Please note that, in a real deployment, the two object pools, "dds/tiny_text" and "/dds/big_chunk", should live in subgroups optimized for the different workloads. Here, for demonstration purpose, we put them in the same volatile subgroup.</li>
</ul>
<p>Then, we create a topic "ta" using the cascade dds client. </p><div class="fragment"><div class="line"># ../../cascade_dds_client</div>
<div class="line">cmd&gt; create_topic ta /dds/tiny_text</div>
<div class="line">-&gt; Succeeded.</div>
<div class="line">cmd&gt; list_topics</div>
<div class="line">TOPIC-1</div>
<div class="line">        name:ta</div>
<div class="line">        path:/dds/tiny_text</div>
<div class="line">cmd&gt; </div>
</div><!-- fragment --><p> Now, we subscribe to topic "ta". </p><div class="fragment"><div class="line">cmd&gt; subscribe ta subscriber_01 </div>
<div class="line">-&gt; Succeeded.</div>
<div class="line">cmd&gt; list_subscribers</div>
<div class="line">1 subscribers found</div>
<div class="line">NAME    TOPIC</div>
<div class="line">=============</div>
<div class="line">subscriber_01   ta</div>
<div class="line">-&gt; Succeeded.</div>
</div><!-- fragment --><p> Here, the tester will register a message handler which prints the message as a string. However, the API allows a DDS application to register whatever handler.</p>
<p>Then, we publish 10 messages to topic "ta" as follows. </p><div class="fragment"><div class="line">cmd&gt; publish ta 10</div>
<div class="line">publisher created for topic:ta</div>
<div class="line">-&gt; Succeeded.</div>
<div class="line">cmd&gt; Message of 22 bytes received in topic &#39;ta&#39;: Message #0 in topic ta</div>
<div class="line">Message of 22 bytes received in topic &#39;ta&#39;: Message #1 in topic ta</div>
<div class="line">Message of 22 bytes received in topic &#39;ta&#39;: Message #2 in topic ta</div>
<div class="line">Message of 22 bytes received in topic &#39;ta&#39;: Message #3 in topic ta</div>
<div class="line">Message of 22 bytes received in topic &#39;ta&#39;: Message #4 in topic ta</div>
<div class="line">Message of 22 bytes received in topic &#39;ta&#39;: Message #5 in topic ta</div>
<div class="line">Message of 22 bytes received in topic &#39;ta&#39;: Message #6 in topic ta</div>
<div class="line">Message of 22 bytes received in topic &#39;ta&#39;: Message #7 in topic ta</div>
<div class="line">Message of 22 bytes received in topic &#39;ta&#39;: Message #8 in topic ta</div>
<div class="line">Message of 22 bytes received in topic &#39;ta&#39;: Message #9 in topic ta</div>
</div><!-- fragment --><p> The messages shown above are printed by the subscriber.</p>
<p>Please refer to <a href="include/cascade_dds/dds.hpp"><code>dds.hpp</code></a> for the DDS API. The <a href="src/client.cpp">cascade DDS tester</a>, as a demonstrates how to implement the above capabilities using the DDS API.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Limitations and Future Works</h2>
<p>There are couple of limitations we plan to address in the future. 1) The DDS UDL can run in multiple threads, therefore the messages in a topic might be sent to the subscribers from different threads. Therefore, a subscriber might receive messages out of order. The current workaround is to limit the size of off critical data path thread pool to 1, by setting <code>num_workers_for_multicast_ocdp</code> to 1 in <code>derecho.cfg</code>. In the future, we plan to add a "thread stickness feature" to control the affinity of messages and worker threads. Using this feature, we can allow only one worker thread for each topic to guarantee message order without disabling multithreading. 2) Sometimes, the application wants to leverage the computation power on the Cascade Server nodes to process topic messages. For example, the servers can be used to preprocess high resolution pictures and delete irrelavent pixels. We plan to introduce a server side API for this DDS so that the application can inject such logics to the server side like how we handle the UDLs. 3) We plan to add stateful DDS by allowing buffering recent topic messages and checkpointing. 4) Currently, the DDS service supports only C++ API. We plan to provide Python and Java API soon. 5) Performance optimization: zero-copy API for big messages. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
